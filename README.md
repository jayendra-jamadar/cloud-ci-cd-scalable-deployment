## Integrating GitHub Actions with CI CD pipeline for deploying a web application on Amazon EC2

These days many companies move towards DevOps because they want to build things faster and also manage software in a smoother way. DevOps is not just about tools it is more about mindset and working style. When teams start using DevOps properly they usually follow certain habits that help them deliver software quickly and safely. One of the most important habits is Continuous Integration and Continuous Delivery. This method helps reduce the time required to release updates because most of the deployment work gets automated. There are many tools available for this but AWS gives its own set of tools while still allowing developers to connect with outside platforms like GitHub which makes the system flexible and easy to extend.

In this work the main focus is using GitHub Actions to create a workflow that automatically builds and deploys an example Java SpringBoot web application onto Amazon EC2 machines that run inside an Auto Scaling setup. The idea is simple but powerful. Code changes happen then deployment happens without manual effort.

GitHub Actions is actually part of GitHub itself which makes it very comfortable for developers because they can manage automation in the same place where they store their code. Developers can write small tasks called actions then join them together to build full workflows. These workflows run automatically and can handle building testing packaging releasing or even deploying projects directly from the repository. It feels like having a silent assistant that keeps running background tasks every time code is updated.

AWS CodeDeploy works as the deployment engine in this setup. It helps push applications onto EC2 servers or even on prem machines or AWS Lambda or container services. The service handles deployment steps which reduces human mistakes and keeps the process consistent. It basically acts like a traffic controller making sure the new version of application reaches the correct servers smoothly.

The solution uses multiple AWS services working together. Each service plays a small role but when combined they create a complete system that feels strong and scalable. GitHub Actions acts as the brain controlling the pipeline. AWS CodeDeploy handles deployment operations on EC2 instances that run inside Auto Scaling groups. Auto Scaling itself keeps application available by adding new servers during heavy traffic and removing them when demand becomes low. Amazon EC2 machines serve as the final destination where the web application actually runs. AWS CloudFormation is used to automatically create infrastructure on AWS instead of setting up each service manually which saves time and avoids configuration mistakes. IAM OIDC identity provider builds trust between GitHub and AWS allowing GitHub workflows to access AWS resources safely without storing secret keys. Amazon S3 works as storage that keeps deployment files before they are sent to servers.

Before starting this implementation certain requirements must be ready. An AWS account is required with permissions to create services. A Git client is required to copy project code. A GitHub account is required to manage repositories workflows and secrets. These are basic but very necessary steps.

The overall walkthrough follows a structured flow. First the project repository is copied from AWS sample resources. Then CloudFormation template is deployed to create AWS infrastructure automatically. After infrastructure is ready source code can be updated based on requirement. GitHub secrets are configured to allow secure communication between GitHub and AWS. CodeDeploy is connected with GitHub repository. Finally GitHub workflow is triggered to build and deploy application and deployment success is verified.

To start working with the project the source code must be downloaded from AWS sample repository. After downloading a new empty repository is created in personal GitHub account. All project files including hidden GitHub workflow folders must be copied into the new repository because those hidden folders contain automation instructions that are necessary for workflow execution.

CloudFormation template deployment is the next step and it builds most of the AWS infrastructure automatically. User needs to open AWS CloudFormation console then sign into account. Region must be selected properly because services will be created inside that region. New stack creation is selected and template file is uploaded from the downloaded repository. Stack details are filled including stack name VPC subnet configuration GitHub repository name and thumbprint list for GitHub authentication. IAM resource creation permission must be acknowledged before stack creation begins. CloudFormation usually takes several minutes to finish building infrastructure and during that time many services get prepared automatically.

The created infrastructure normally includes two Linux based EC2 machines running Tomcat server along with CodeDeploy agent installed inside them. It also builds Auto Scaling group combined with internet facing load balancer which distributes traffic across instances. CodeDeploy application and deployment group are created to manage application updates. S3 bucket is created for storing build files. IAM OIDC identity provider is created for secure authentication between GitHub and AWS. EC2 instance profile and CodeDeploy service role are also generated automatically. Security groups are created to control network traffic between load balancer and EC2 machines.

After infrastructure setup GitHub configuration becomes important. GitHub workflows must be configured correctly along with secrets that allow workflow to interact with AWS resources. Once configuration is complete GitHub action workflow can be triggered. The workflow builds project packages deployment files uploads them to S3 then CodeDeploy deploys application on EC2 instances. Deployment verification is done by checking application running status through load balancer or EC2 public address.

Cleaning resources after testing is a responsible step because unused cloud services may generate unwanted charges. S3 bucket contents should be emptied first. After that CloudFormation stack should be deleted which automatically removes most AWS resources created earlier. GitHub secrets related to IAM role should also be removed from repository settings to maintain security.
